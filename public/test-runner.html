<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audio Analysis Test Runner</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0a0a0f 100%);
      color: #fff;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      padding: 20px;
      padding-bottom: 60px;
    }

    .version-footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 8px 16px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.5);
      font-size: 12px;
      text-align: center;
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .settings-btn {
      position: absolute;
      right: 16px;
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.5);
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
    }

    .settings-btn:hover {
      color: rgba(255, 255, 255, 0.9);
      background: rgba(255, 255, 255, 0.1);
      transform: none;
      box-shadow: none;
    }

    .settings-btn svg {
      width: 14px;
      height: 14px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(29, 185, 84, 0.3);
    }

    header h1 {
      font-size: 2rem;
      color: #1DB954;
      margin-bottom: 10px;
    }

    header p {
      color: rgba(255, 255, 255, 0.6);
    }

    section {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }

    section h2 {
      font-size: 1.1rem;
      color: rgba(255, 255, 255, 0.9);
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    button {
      background: linear-gradient(135deg, #1DB954 0%, #1ed760 100%);
      color: #000;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(29, 185, 84, 0.4);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    button.secondary {
      background: linear-gradient(135deg, #333 0%, #444 100%);
      color: #fff;
    }

    button.stop {
      background: linear-gradient(135deg, #ff6b6b 0%, #ff8e72 100%);
    }

    #status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(29, 185, 84, 0.1);
      border: 1px solid rgba(29, 185, 84, 0.3);
      color: #1DB954;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 14px;
      margin-bottom: 20px;
    }

    #status.running {
      background: rgba(255, 193, 7, 0.1);
      border-color: rgba(255, 193, 7, 0.3);
      color: #ffc107;
    }

    #status.error {
      background: rgba(255, 107, 107, 0.1);
      border-color: rgba(255, 107, 107, 0.3);
      color: #ff6b6b;
    }

    .spinner {
      display: inline-block;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    #canvas {
      width: 100%;
      max-width: 800px;
      height: 400px;
      background: #0a0a0f;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: block;
    }

    .results-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .result-wrapper {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      border-left: 3px solid;
      overflow: hidden;
    }
    
    .result-wrapper.passed {
      border-color: #1DB954;
    }

    .result-wrapper.failed {
      border-color: #ff6b6b;
    }

    .result-item {
      display: grid;
      grid-template-columns: 30px 30px 160px 1fr 80px;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .result-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }
    
    .result-toggle {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
      transition: transform 0.2s;
      user-select: none;
    }
    
    .result-wrapper.expanded .result-toggle {
      transform: rotate(90deg);
    }
    
    .result-name {
      font-weight: 600;
      color: rgba(255, 255, 255, 0.9);
    }
    
    .result-data {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
      font-family: monospace;
      background: rgba(0, 0, 0, 0.3);
      padding: 4px 8px;
      border-radius: 4px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .result-time {
      font-size: 12px;
      color: #4dabf7;
      text-align: right;
      font-family: monospace;
    }
    
    .result-details {
      display: none;
      padding: 0 16px 16px 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .result-wrapper.expanded .result-details {
      display: block;
    }
    
    .result-chart {
      width: 100%;
      height: 200px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      margin-bottom: 10px;
    }
    
    .result-raw-data {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      padding: 12px;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.7);
      white-space: pre-wrap;
      word-break: break-all;
    }
    
    .result-stats {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px;
      margin-bottom: 10px;
    }
    
    .stat-item {
      background: rgba(0, 0, 0, 0.4);
      padding: 8px 12px;
      border-radius: 6px;
      text-align: center;
    }
    
    .stat-label {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.5);
      text-transform: uppercase;
    }
    
    .stat-value {
      font-size: 14px;
      font-weight: 600;
      color: #1DB954;
    }

    .data-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 12px;
    }

    .data-item {
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      border-radius: 8px;
      text-align: center;
    }

    .data-label {
      display: block;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 4px;
    }

    .data-value {
      display: block;
      font-size: 18px;
      font-weight: 600;
      color: #1DB954;
    }

    #console {
      background: #000;
      border-radius: 8px;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
      color: #0f0;
    }

    #console .log { color: #fff; }
    #console .info { color: #4dabf7; }
    #console .warn { color: #ffc107; }
    #console .error { color: #ff6b6b; }

    .hidden { display: none !important; }

    #file-input {
      display: none;
    }
  </style>
  
  <!-- Plotly for charts -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
  <div class="container">
    <header>
      <h1>üéµ Audio Analysis Test Runner</h1>
      <p>MP3 Decoding & Visualization Testing (Dev Mode)</p>
    </header>

    <section>
      <h2>Test Controls</h2>
      <div class="button-group">
        <button id="btn-custom" class="secondary">üìÅ Load Custom MP3</button>
        <button id="btn-analysis">üî¨ Run Analysis Tests</button>
        <button id="btn-animate">‚ñ∂Ô∏è Play Animation</button>
        <button id="btn-stop" class="stop hidden">‚èπÔ∏è Stop</button>
      </div>
      <input type="file" id="file-input" accept=".mp3,audio/mpeg">
    </section>

    <div id="status">Ready to run tests</div>

    <section>
      <h2>Visualization Output</h2>
      <canvas id="canvas" width="800" height="400"></canvas>
    </section>

    <section id="results-section" class="hidden">
      <h2>Test Results</h2>
      <div id="results" class="results-list"></div>
    </section>

    <section id="data-section" class="hidden">
      <h2>Analysis Data</h2>
      <div id="data-grid" class="data-grid"></div>
    </section>

    <section>
      <h2>Console Output</h2>
      <div id="console"></div>
    </section>
  </div>

  <!-- Load Essentia.js (local files for reliability and offline use) -->
  <script src="/essentia-wasm.web.js"></script>
  <script src="/essentia.js-core.js"></script>

  <script type="module">
    // =====================================================
    // Audio Analysis Service (inline for standalone page)
    // =====================================================
    
    const SAMPLE_RATE = 44100;
    const FRAME_SIZE = 2048;
    const HOP_SIZE = 1024;

    let essentia = null;
    let isEssentiaLoaded = false;

    async function loadEssentia() {
      if (isEssentiaLoaded && essentia) return essentia;
      
      log('üéµ Initializing Essentia.js...', 'info');
      
      try {
        const essentiaWASM = await window.EssentiaWASM();
        essentia = new window.Essentia(essentiaWASM);
        isEssentiaLoaded = true;
        log('‚úÖ Essentia.js loaded successfully!', 'info');
        return essentia;
      } catch (error) {
        log('‚ùå Failed to load Essentia.js: ' + error.message, 'error');
        throw error;
      }
    }

    async function fetchAudioBuffer(audioUrl) {
      log('üì• Fetching audio: ' + audioUrl, 'info');
      
      const audioContext = new (window.AudioContext || window.webkitAudioContext)({
        sampleRate: SAMPLE_RATE
      });
      
      const response = await fetch(audioUrl);
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
      
      log(`‚úÖ Audio decoded: ${audioBuffer.duration.toFixed(2)}s @ ${audioBuffer.sampleRate}Hz`, 'info');
      return audioBuffer;
    }

    function audioBufferToMono(audioBuffer) {
      const numChannels = audioBuffer.numberOfChannels;
      const length = audioBuffer.length;
      const monoData = new Float32Array(length);
      
      if (numChannels === 1) {
        monoData.set(audioBuffer.getChannelData(0));
      } else {
        const left = audioBuffer.getChannelData(0);
        const right = audioBuffer.getChannelData(1);
        for (let i = 0; i < length; i++) {
          monoData[i] = (left[i] + right[i]) / 2;
        }
      }
      
      return monoData;
    }

    // =====================================================
    // Pure JS FFT Implementation (avoids Essentia WASM crashes)
    // =====================================================
    
    // Simple FFT using Web Audio API's AnalyserNode approach
    function computeSpectrum(frameData) {
      const N = frameData.length;
      const spectrum = new Float32Array(N / 2);
      
      // Apply Hann window
      const windowed = new Float32Array(N);
      for (let i = 0; i < N; i++) {
        const windowValue = 0.5 * (1 - Math.cos(2 * Math.PI * i / (N - 1)));
        windowed[i] = frameData[i] * windowValue;
      }
      
      // Simple DFT for small frame sizes (not optimal but works)
      // For better performance, use a proper FFT library
      for (let k = 0; k < N / 2; k++) {
        let real = 0, imag = 0;
        for (let n = 0; n < N; n++) {
          const angle = -2 * Math.PI * k * n / N;
          real += windowed[n] * Math.cos(angle);
          imag += windowed[n] * Math.sin(angle);
        }
        spectrum[k] = Math.sqrt(real * real + imag * imag) / N;
      }
      
      return spectrum;
    }
    
    // Fast approximation using downsampled DFT
    function computeSpectrumFast(frameData, outputBins = 128) {
      const N = frameData.length;
      const spectrum = new Float32Array(outputBins);
      
      // Apply Hann window
      const windowed = new Float32Array(N);
      for (let i = 0; i < N; i++) {
        const windowValue = 0.5 * (1 - Math.cos(2 * Math.PI * i / (N - 1)));
        windowed[i] = frameData[i] * windowValue;
      }
      
      // Compute only the bins we need
      for (let k = 0; k < outputBins; k++) {
        let real = 0, imag = 0;
        const freq = k * (N / 2) / outputBins;
        
        // Downsample the computation
        const step = Math.max(1, Math.floor(N / 256));
        for (let n = 0; n < N; n += step) {
          const angle = -2 * Math.PI * freq * n / N;
          real += windowed[n] * Math.cos(angle);
          imag += windowed[n] * Math.sin(angle);
        }
        spectrum[k] = Math.sqrt(real * real + imag * imag) / (N / step);
      }
      
      return spectrum;
    }

    async function extractMelSpectrogram(audioSignal, sampleRate = SAMPLE_RATE) {
      log('üéº Extracting Mel Spectrogram (10fps)...', 'info');
      
      const frames = [];
      const numBands = 40;
      const frameSize = 2048;
      
      // Target 10fps frame intervals (sufficient for smooth visualization)
      const targetFrameInterval = 0.1; // seconds (10fps)
      const samplesPerFrame = Math.round(targetFrameInterval * sampleRate);
      const totalDuration = audioSignal.length / sampleRate;
      const numFrames = Math.floor(totalDuration / targetFrameInterval);
      
      log(`   Processing ${numFrames} frames at 10fps from ${totalDuration.toFixed(1)}s audio...`, 'info');
      
      try {
        for (let i = 0; i < numFrames; i++) {
          const frameTime = i * targetFrameInterval;
          const startSample = Math.round(frameTime * sampleRate);
          const frameData = audioSignal.slice(startSample, startSample + frameSize);
          
          if (frameData.length < frameSize) break;
          
          // Use fast spectrum computation
          const spectrum = computeSpectrumFast(frameData, numBands * 2);
          
          // Group into mel-like bands (simplified - not true mel scale)
          const bands = [];
          const binsPerBand = 2;
          for (let b = 0; b < numBands; b++) {
            let sum = 0;
            for (let j = 0; j < binsPerBand; j++) {
              sum += spectrum[b * binsPerBand + j] || 0;
            }
            // Log scale for better visualization
            bands.push(Math.log10(1 + sum * 100) * 10);
          }
          
          frames.push({ 
            time: frameTime, 
            bands: bands 
          });
        }
        
        log(`‚úÖ Extracted ${frames.length} mel frames`, 'info');
        return frames;
        
      } catch (error) {
        log('‚ö†Ô∏è Mel extraction error: ' + (error.message || error.toString()), 'warn');
        console.error('Mel error:', error);
        return [];
      }
    }

    async function extractHPCPChroma(audioSignal, sampleRate = SAMPLE_RATE) {
      log('üéº Extracting Chroma (30fps)...', 'info');
      
      const frames = [];
      const frameSize = 2048;
      
      // Target 30fps frame intervals for chroma (lighter computation)
      const targetFrameInterval = 0.0333; // seconds (30fps)
      const totalDuration = audioSignal.length / sampleRate;
      const numFrames = Math.floor(totalDuration / targetFrameInterval);
      
      log(`   Processing ${numFrames} chroma frames at 30fps...`, 'info');
      
      try {
        for (let i = 0; i < numFrames; i++) {
          const frameTime = i * targetFrameInterval;
          const startSample = Math.round(frameTime * sampleRate);
          const frameData = audioSignal.slice(startSample, startSample + frameSize);
          
          if (frameData.length < frameSize) break;
          
          // Compute spectrum with enough resolution for chroma
          const spectrum = computeSpectrumFast(frameData, 256);
          
          // Map to 12 pitch classes
          const chroma = new Array(12).fill(0);
          const nyquist = sampleRate / 2;
          const numBins = spectrum.length;
          
          for (let bin = 1; bin < numBins; bin++) {
            const freq = (bin / numBins) * nyquist;
            if (freq > 60 && freq < 4000) {
              // Convert frequency to pitch class
              const midiNote = 12 * Math.log2(freq / 440) + 69;
              const pitchClass = Math.round(midiNote) % 12;
              if (pitchClass >= 0 && pitchClass < 12) {
                chroma[pitchClass] += spectrum[bin];
              }
            }
          }
          
          // Normalize
          const maxChroma = Math.max(...chroma, 0.001);
          const normalizedChroma = chroma.map(c => c / maxChroma);
          
          frames.push({ 
            time: frameTime, 
            chroma: normalizedChroma 
          });
        }
        
        log(`‚úÖ Extracted ${frames.length} chroma frames`, 'info');
        return frames;
        
      } catch (error) {
        log('‚ö†Ô∏è Chroma extraction error: ' + (error.message || error.toString()), 'warn');
        console.error('Chroma error:', error);
        return [];
      }
    }

    // Pitch extraction using dedicated Web Worker file
    async function extractPitch(audioSignal, sampleRate = SAMPLE_RATE) {
      log('üéº Extracting Pitch (Web Worker)...', 'info');
      
      return new Promise((resolve, reject) => {
        // Create worker from dedicated file
        const worker = new Worker('/pitch-worker.js');
        
        worker.onmessage = (e) => {
          const { type, frames, totalFrames, message } = e.data;
          
          if (type === 'progress') {
            log(`   ${message}`, 'info');
          } else if (type === 'result') {
            log(`‚úÖ Extracted ${frames.length} pitch frames (30fps)`, 'info');
            worker.terminate();
            resolve(frames);
          } else if (type === 'error') {
            log(`‚ùå Pitch worker error: ${message}`, 'error');
            worker.terminate();
            reject(new Error(message));
          }
        };
        
        worker.onerror = (error) => {
          log(`‚ùå Worker error: ${error.message}`, 'error');
          console.error('Worker error:', error);
          worker.terminate();
          reject(new Error(error.message || 'Worker failed'));
        };
        
        // Copy audio data and send to worker
        const audioArray = new Float32Array(audioSignal);
        worker.postMessage(
          { audioSignal: audioArray, sampleRate, frameSize: FRAME_SIZE },
          [audioArray.buffer]  // Transfer ownership for performance
        );
      });
    }

    async function extractRhythm(audioSignal, sampleRate = SAMPLE_RATE) {
      if (!essentia) await loadEssentia();
      
      log('üéº Extracting Rhythm...', 'info');
      
      const signalVector = essentia.arrayToVector(audioSignal);
      const rhythmResult = essentia.RhythmExtractor2013(signalVector, 208, 'degara', 40);
      
      const result = {
        bpm: rhythmResult.bpm,
        beats: essentia.vectorToArray(rhythmResult.ticks),
        confidence: rhythmResult.confidence
      };
      
      signalVector.delete();
      rhythmResult.ticks.delete();
      
      log(`‚úÖ BPM: ${result.bpm.toFixed(1)}, ${result.beats.length} beats`, 'info');
      return result;
    }

    async function analyzeAudio(audioUrl) {
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
      log('üéµ Starting Full Audio Analysis', 'info');
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
      
      const startTime = Date.now();
      
      await loadEssentia();
      
      const audioBuffer = await fetchAudioBuffer(audioUrl);
      const monoSignal = audioBufferToMono(audioBuffer);
      
      let melSpectrogram = [];
      let hpcpChroma = [];
      let pitch = [];
      let rhythm = { bpm: 120, beats: [], confidence: 0 };
      
      try { rhythm = await extractRhythm(monoSignal, audioBuffer.sampleRate); } 
      catch (e) { log('‚ö†Ô∏è Rhythm failed: ' + e.message, 'warn'); }
      
      try { pitch = await extractPitch(monoSignal, audioBuffer.sampleRate); }
      catch (e) { log('‚ö†Ô∏è Pitch failed: ' + e.message, 'warn'); }
      
      try { melSpectrogram = await extractMelSpectrogram(monoSignal, audioBuffer.sampleRate); }
      catch (e) { log('‚ö†Ô∏è Mel failed: ' + e.message, 'warn'); }
      
      try { hpcpChroma = await extractHPCPChroma(monoSignal, audioBuffer.sampleRate); }
      catch (e) { log('‚ö†Ô∏è Chroma failed: ' + e.message, 'warn'); }
      
      const analysisTime = ((Date.now() - startTime) / 1000).toFixed(2);
      
      log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
      log(`‚úÖ Analysis complete in ${analysisTime}s`, 'info');
      
      return {
        duration: audioBuffer.duration,
        sampleRate: audioBuffer.sampleRate,
        analysisTime: parseFloat(analysisTime),
        features: { melSpectrogram, hpcpChroma, pitch, rhythm }
      };
    }

    function getAnalysisAtTime(analysisData, timeInSeconds) {
      if (!analysisData || !analysisData.features) return null;
      
      const { melSpectrogram, hpcpChroma, pitch, rhythm } = analysisData.features;
      
      const findClosestFrame = (frames, time) => {
        if (!frames || frames.length === 0) return null;
        let left = 0, right = frames.length - 1;
        while (left < right) {
          const mid = Math.floor((left + right) / 2);
          if (frames[mid].time < time) left = mid + 1;
          else right = mid;
        }
        if (left > 0 && Math.abs(frames[left - 1].time - time) < Math.abs(frames[left].time - time)) {
          return frames[left - 1];
        }
        return frames[left];
      };
      
      const isOnBeat = (time, beats, tolerance = 0.05) => {
        if (!beats) return { onBeat: false, beatStrength: 0 };
        for (let i = 0; i < beats.length; i++) {
          const diff = Math.abs(time - beats[i]);
          if (diff < tolerance) {
            const strength = 1 - (diff / tolerance);
            return { onBeat: true, beatStrength: strength * (i % 4 === 0 ? 1.5 : 1), beatIndex: i };
          }
        }
        return { onBeat: false, beatStrength: 0 };
      };
      
      return {
        time: timeInSeconds,
        mel: findClosestFrame(melSpectrogram, timeInSeconds)?.bands || null,
        chroma: findClosestFrame(hpcpChroma, timeInSeconds)?.chroma || null,
        pitch: findClosestFrame(pitch, timeInSeconds)?.pitch || 0,
        pitchConfidence: findClosestFrame(pitch, timeInSeconds)?.confidence || 0,
        bpm: rhythm?.bpm || 120,
        ...isOnBeat(timeInSeconds, rhythm?.beats)
      };
    }

    // =====================================================
    // UI & Test Runner
    // =====================================================
    
    const COLORS = {
      chroma: ['#ff6b6b', '#ff8e72', '#ffa94d', '#ffd43b', '#a9e34b', '#69db7c',
               '#38d9a9', '#3bc9db', '#4dabf7', '#748ffc', '#9775fa', '#da77f2']
    };

    // Chroma hues for pitch class visualization (0-330 in 30 degree steps)
    const CHROMA_HUES = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330];

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const consoleEl = document.getElementById('console');
    const resultsEl = document.getElementById('results');
    const dataGridEl = document.getElementById('data-grid');
    
    let analysisData = null;
    let animationId = null;
    let visualizationState = 'idle'; // 'idle', 'loading', 'playing'
    let idleAnimationId = null;
    
    // Track currently loaded MP3 file
    let currentAudioUrl = '/test-fixtures/test-audio.mp3';
    let currentAudioFileName = 'test-audio.mp3';

    // Pitch class names for visualization
    const PITCH_CLASSES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    // Visualization state for animations
    const vizState = {
      beatPulse: 0,
      dominantHue: 140,
      energyLevel: 0,
      lastBeatTime: 0,
      particles: [],
      chromaRotation: 0
    };

    // Initialize particle system
    function initParticles(width, height) {
      const NUM_PARTICLES = 40;
      vizState.particles = [];
      for (let i = 0; i < NUM_PARTICLES; i++) {
        vizState.particles.push({
          x: Math.random() * width,
          y: Math.random() * height,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          size: Math.random() * 3 + 1,
          hue: Math.random() * 60 + 100,
          alpha: Math.random() * 0.5 + 0.3
        });
      }
    }

    function log(message, type = 'log') {
      const line = document.createElement('div');
      line.className = type;
      line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      consoleEl.appendChild(line);
      consoleEl.scrollTop = consoleEl.scrollHeight;
      console[type] ? console[type](message) : console.log(message);
    }

    function setStatus(text, type = '') {
      statusEl.textContent = text;
      statusEl.className = type;
    }

    function addResult(name, passed, data, timeMs, rawData = null, chartConfig = null) {
      document.getElementById('results-section').classList.remove('hidden');
      
      const wrapper = document.createElement('div');
      wrapper.className = `result-wrapper ${passed ? 'passed' : 'failed'}`;
      
      const timeStr = timeMs !== undefined ? `${(timeMs / 1000).toFixed(2)}s` : '-';
      const baseChartId = `chart-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      // Normalize chartConfig to array
      const chartConfigs = chartConfig ? (Array.isArray(chartConfig) ? chartConfig : [chartConfig]) : [];
      
      // Calculate stats from raw data
      let statsHtml = '';
      if (rawData && rawData.stats) {
        statsHtml = '<div class="result-stats">';
        for (const [key, value] of Object.entries(rawData.stats)) {
          statsHtml += `<div class="stat-item"><div class="stat-label">${key}</div><div class="stat-value">${value}</div></div>`;
        }
        statsHtml += '</div>';
      }
      
      // Prepare raw data display (first 50 items)
      let rawDataDisplay = '';
      if (rawData && rawData.samples) {
        const samples = rawData.samples.slice(0, 50);
        rawDataDisplay = JSON.stringify(samples, null, 2);
        if (rawData.samples.length > 50) {
          rawDataDisplay += `\n\n... and ${rawData.samples.length - 50} more items`;
        }
      }
      
      // Generate chart containers HTML
      const chartsHtml = chartConfigs.map((_, i) => `<div id="${baseChartId}-${i}" class="result-chart"></div>`).join('');
      
      wrapper.innerHTML = `
        <div class="result-item">
          <span>${passed ? '‚úÖ' : '‚ùå'}</span>
          <span class="result-toggle">‚ñ∂</span>
          <span class="result-name">${name}</span>
          <span class="result-data">${data || '-'}</span>
          <span class="result-time">${timeStr}</span>
        </div>
        <div class="result-details">
          ${statsHtml}
          ${chartsHtml}
          ${rawDataDisplay ? `<div class="result-raw-data">${rawDataDisplay}</div>` : '<div class="result-raw-data">No detailed data available</div>'}
        </div>
      `;
      
      // Toggle expand/collapse
      const item = wrapper.querySelector('.result-item');
      item.addEventListener('click', () => {
        wrapper.classList.toggle('expanded');
        
        // Render charts when expanded (lazy load)
        if (wrapper.classList.contains('expanded') && chartConfigs.length > 0 && !wrapper.dataset.chartRendered) {
          wrapper.dataset.chartRendered = 'true';
          chartConfigs.forEach((config, i) => {
            setTimeout(() => renderChart(`${baseChartId}-${i}`, config), 100 * (i + 1));
          });
        }
      });
      
      resultsEl.appendChild(wrapper);
    }
    
    // Render Plotly chart
    function renderChart(containerId, config) {
      const container = document.getElementById(containerId);
      if (!container || !config) return;
      
      const layout = {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0.3)',
        font: { color: 'rgba(255,255,255,0.7)', size: 10 },
        margin: { l: 50, r: 20, t: 30, b: 40 },
        xaxis: { 
          gridcolor: 'rgba(255,255,255,0.1)',
          title: config.xTitle || ''
        },
        yaxis: { 
          gridcolor: 'rgba(255,255,255,0.1)',
          title: config.yTitle || ''
        },
        title: {
          text: config.title || '',
          font: { size: 12 }
        },
        showlegend: config.showLegend || false
      };
      
      Plotly.newPlot(containerId, config.traces, layout, { 
        responsive: true,
        displayModeBar: false 
      });
    }
    
    // =====================================================
    // THREE VISUALIZATION STATES
    // =====================================================
    
    // IDLE ANIMATION: Gentle floating orbs when no music is playing
    function drawIdleVisualization(ctx, width, height, time) {
      const centerX = width / 2;
      const centerY = height / 2;
      
      // Solid dark background for idle (no trailing)
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, width, height);
      
      // Draw subtle gradient background
      const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(width, height) * 0.6);
      bgGradient.addColorStop(0, 'rgba(29, 185, 84, 0.05)');
      bgGradient.addColorStop(1, 'rgba(10, 10, 15, 0)');
      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, width, height);
      
      // Floating orbs
      const numOrbs = 6;
      for (let i = 0; i < numOrbs; i++) {
        const angle = (i / numOrbs) * Math.PI * 2 + time * 0.3;
        const radius = 100 + Math.sin(time * 0.5 + i * 1.2) * 40;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius * 0.6;
        const orbSize = 10 + Math.sin(time * 0.8 + i) * 5;
        
        // Orb glow
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, orbSize * 4);
        gradient.addColorStop(0, 'rgba(29, 185, 84, 0.5)');
        gradient.addColorStop(0.4, 'rgba(29, 185, 84, 0.15)');
        gradient.addColorStop(1, 'rgba(29, 185, 84, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, orbSize * 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Orb core
        ctx.fillStyle = `rgba(29, 185, 84, ${0.7 + Math.sin(time + i) * 0.2})`;
        ctx.beginPath();
        ctx.arc(x, y, orbSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Central breathing circle
      const breathe = Math.sin(time * 0.6) * 0.3 + 0.7;
      const centralSize = 50 * breathe;
      
      const centralGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, centralSize * 2.5);
      centralGradient.addColorStop(0, `rgba(29, 185, 84, ${0.35 * breathe})`);
      centralGradient.addColorStop(0.5, `rgba(29, 185, 84, ${0.12 * breathe})`);
      centralGradient.addColorStop(1, 'rgba(29, 185, 84, 0)');
      ctx.fillStyle = centralGradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, centralSize * 2.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Outer rings
      for (let r = 0; r < 3; r++) {
        const ringSize = centralSize * (1 + r * 0.5) + Math.sin(time * 0.8 + r) * 10;
        const ringAlpha = (0.25 - r * 0.07) * breathe;
        ctx.beginPath();
        ctx.arc(centerX, centerY, ringSize, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(29, 185, 84, ${ringAlpha})`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      // "Waiting" text
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.font = '14px "Orbitron", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('Waiting for music...', centerX, height - 40);
    }

    // LOADING ANIMATION: Spinning rings when processing audio
    function drawLoadingVisualization(ctx, width, height, time) {
      const centerX = width / 2;
      const centerY = height / 2;
      
      // Solid dark background for loading
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, width, height);
      
      // Subtle pulsing background glow
      const pulseAlpha = 0.03 + Math.sin(time * 2) * 0.02;
      const bgGlow = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(width, height) * 0.5);
      bgGlow.addColorStop(0, `rgba(29, 185, 84, ${pulseAlpha})`);
      bgGlow.addColorStop(1, 'rgba(10, 10, 15, 0)');
      ctx.fillStyle = bgGlow;
      ctx.fillRect(0, 0, width, height);
      
      // Multiple spinning rings
      const numRings = 4;
      for (let r = 0; r < numRings; r++) {
        const radius = 50 + r * 35;
        const speed = (r % 2 === 0 ? 1 : -1) * (1.5 - r * 0.2);
        const startAngle = time * speed;
        const arcLength = Math.PI * (0.6 + r * 0.15);
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, startAngle + arcLength);
        
        const hue = 140 + r * 15;
        const alpha = 0.7 - r * 0.1;
        ctx.strokeStyle = `hsla(${hue}, 80%, 55%, ${alpha})`;
        ctx.lineWidth = 4 - r * 0.5;
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.lineCap = 'butt';
        
        // Ring glow
        ctx.shadowColor = `hsla(${hue}, 80%, 55%, 0.5)`;
        ctx.shadowBlur = 10;
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
      
      // Central spinning dot cluster
      const numDots = 8;
      for (let i = 0; i < numDots; i++) {
        const angle = (i / numDots) * Math.PI * 2 + time * 3;
        const dotRadius = 30;
        const x = centerX + Math.cos(angle) * dotRadius;
        const y = centerY + Math.sin(angle) * dotRadius;
        const dotSize = 4 + Math.sin(time * 4 + i) * 2;
        
        ctx.fillStyle = `rgba(29, 185, 84, ${0.6 + Math.sin(time * 3 + i) * 0.3})`;
        ctx.beginPath();
        ctx.arc(x, y, dotSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Animated dots text
      const dots = '.'.repeat(Math.floor(time * 2) % 4);
      ctx.fillStyle = '#1DB954';
      ctx.font = '16px "Orbitron", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`Analyzing Audio${dots}`, centerX, height - 50);
      
      // Progress bar style indicator
      const progressWidth = width * 0.4;
      const progressHeight = 4;
      const progressY = height - 30;
      const progressX = centerX - progressWidth / 2;
      
      // Background track
      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.fillRect(progressX, progressY, progressWidth, progressHeight);
      
      // Animated fill
      const fillWidth = (Math.sin(time * 1.5) * 0.5 + 0.5) * progressWidth;
      const gradient = ctx.createLinearGradient(progressX, 0, progressX + progressWidth, 0);
      gradient.addColorStop(0, 'rgba(29, 185, 84, 0.3)');
      gradient.addColorStop(0.5, 'rgba(29, 185, 84, 0.8)');
      gradient.addColorStop(1, 'rgba(29, 185, 84, 0.3)');
      ctx.fillStyle = gradient;
      ctx.fillRect(progressX, progressY, fillWidth, progressHeight);
    }

    // Draw circular mel spectrogram around the edges
    function drawCircularMel(ctx, centerX, centerY, radius, mel, beatPulse, dominantHue) {
      if (!mel || mel.length === 0) return;
      
      const numBars = mel.length;
      const angleStep = (Math.PI * 2) / numBars;
      const maxBarHeight = radius * 0.3;
      
      for (let i = 0; i < numBars; i++) {
        const angle = i * angleStep - Math.PI / 2;
        const value = Math.max(0, Math.min(1, (mel[i] + 10) / 10));
        const barHeight = value * maxBarHeight * (1 + beatPulse * 0.3);
        
        const innerRadius = radius * 0.85;
        const outerRadius = innerRadius + barHeight;
        
        const x1 = centerX + Math.cos(angle - angleStep * 0.3) * innerRadius;
        const y1 = centerY + Math.sin(angle - angleStep * 0.3) * innerRadius;
        const x2 = centerX + Math.cos(angle - angleStep * 0.3) * outerRadius;
        const y2 = centerY + Math.sin(angle - angleStep * 0.3) * outerRadius;
        const x3 = centerX + Math.cos(angle + angleStep * 0.3) * outerRadius;
        const y3 = centerY + Math.sin(angle + angleStep * 0.3) * outerRadius;
        const x4 = centerX + Math.cos(angle + angleStep * 0.3) * innerRadius;
        const y4 = centerY + Math.sin(angle + angleStep * 0.3) * innerRadius;
        
        const hue = dominantHue + (i / numBars) * 60;
        const lightness = 40 + value * 35 + beatPulse * 15;
        
        ctx.fillStyle = `hsla(${hue}, 75%, ${lightness}%, ${0.7 + value * 0.3})`;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.lineTo(x4, y4);
        ctx.closePath();
        ctx.fill();
      }
    }

    // Draw chroma wheel as a rotating flower
    function drawChromaWheel(ctx, centerX, centerY, radius, chroma, rotation, beatPulse) {
      if (!chroma || chroma.length !== 12) return;
      
      for (let i = 0; i < 12; i++) {
        const value = chroma[i] || 0;
        const angle = (i / 12) * Math.PI * 2 + rotation - Math.PI / 2;
        const petalLength = radius * (0.3 + value * 0.5) * (1 + beatPulse * 0.2);
        
        // Draw petal
        ctx.beginPath();
        const petalWidth = Math.PI / 16;
        ctx.moveTo(centerX, centerY);
        ctx.quadraticCurveTo(
          centerX + Math.cos(angle - petalWidth) * petalLength * 0.7,
          centerY + Math.sin(angle - petalWidth) * petalLength * 0.7,
          centerX + Math.cos(angle) * petalLength,
          centerY + Math.sin(angle) * petalLength
        );
        ctx.quadraticCurveTo(
          centerX + Math.cos(angle + petalWidth) * petalLength * 0.7,
          centerY + Math.sin(angle + petalWidth) * petalLength * 0.7,
          centerX,
          centerY
        );
        
        const hue = CHROMA_HUES[i];
        ctx.fillStyle = `hsla(${hue}, 80%, ${45 + value * 30}%, ${0.5 + value * 0.5})`;
        ctx.fill();
        
        // Pitch class label
        const labelDist = radius * 0.75;
        const labelX = centerX + Math.cos(angle) * labelDist;
        const labelY = centerY + Math.sin(angle) * labelDist;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + value * 0.5})`;
        ctx.font = '9px "Orbitron", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(PITCH_CLASSES[i], labelX, labelY);
      }
    }

    // Draw central pitch orb with 3D effect
    function drawPitchOrb(ctx, centerX, centerY, radius, pitch, confidence, beatPulse, dominantHue) {
      const orbRadius = radius * 0.22 * (1 + beatPulse * 0.15);
      
      // Outer glow
      const glowGradient = ctx.createRadialGradient(
        centerX, centerY, orbRadius * 0.5,
        centerX, centerY, orbRadius * 2
      );
      glowGradient.addColorStop(0, `hsla(${dominantHue}, 80%, 60%, ${0.3 + beatPulse * 0.3})`);
      glowGradient.addColorStop(1, 'hsla(0, 0%, 0%, 0)');
      ctx.fillStyle = glowGradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, orbRadius * 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Main orb with 3D gradient
      const orbGradient = ctx.createRadialGradient(
        centerX - orbRadius * 0.3, centerY - orbRadius * 0.3, 0,
        centerX, centerY, orbRadius
      );
      orbGradient.addColorStop(0, `hsla(${dominantHue}, 70%, 70%, 0.95)`);
      orbGradient.addColorStop(0.5, `hsla(${dominantHue}, 80%, 50%, 0.9)`);
      orbGradient.addColorStop(1, `hsla(${dominantHue}, 90%, 30%, 0.85)`);
      
      ctx.fillStyle = orbGradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, orbRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.beginPath();
      ctx.ellipse(
        centerX - orbRadius * 0.25, 
        centerY - orbRadius * 0.25, 
        orbRadius * 0.3, 
        orbRadius * 0.2, 
        -Math.PI / 4, 0, Math.PI * 2
      );
      ctx.fill();
      
      // Pitch text
      if (pitch > 0 && confidence > 0.3) {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px "Orbitron", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${Math.round(pitch)}Hz`, centerX, centerY);
      }
    }

    // Update and draw particles
    function updateAndDrawParticles(ctx, width, height, beatPulse, dominantHue, energyLevel) {
      if (!vizState.particles || vizState.particles.length === 0) {
        initParticles(width, height);
      }
      
      const centerX = width / 2;
      const centerY = height / 2;
      
      for (let p of vizState.particles) {
        // Apply energy-based velocity boost
        const boost = 1 + energyLevel * 2 + beatPulse * 3;
        p.x += p.vx * boost;
        p.y += p.vy * boost;
        
        // Wrap around edges
        if (p.x < 0) p.x = width;
        if (p.x > width) p.x = 0;
        if (p.y < 0) p.y = height;
        if (p.y > height) p.y = 0;
        
        // Draw particle with energy-reactive size
        const size = p.size * (1 + beatPulse * 2 + energyLevel);
        const hue = (p.hue + dominantHue) % 360;
        
        ctx.fillStyle = `hsla(${hue}, 70%, 60%, ${p.alpha * (0.5 + energyLevel * 0.5)})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Chroma-colored sound waves - layered waves for each pitch class
    function drawChromaSoundWaves(ctx, width, height, chroma, mel, beatPulse, time) {
      if (!chroma || chroma.length !== 12) return;
      
      const baseY = height * 0.92;
      const maxWaveHeight = height * 0.15;
      const numPoints = 60;
      
      // Draw 12 layered waves, one for each pitch class
      // Draw from back to front (lowest intensity to highest)
      const sortedIndices = [...Array(12).keys()].sort((a, b) => chroma[a] - chroma[b]);
      
      for (const chromaIdx of sortedIndices) {
        const chromaValue = chroma[chromaIdx] || 0;
        if (chromaValue < 0.1) continue; // Skip very quiet pitch classes
        
        const hue = CHROMA_HUES[chromaIdx];
        const waveHeight = maxWaveHeight * (0.3 + chromaValue * 0.7);
        const phaseOffset = chromaIdx * 0.5; // Each pitch class has different phase
        const speed = 1.5 + chromaIdx * 0.1;
        
        ctx.beginPath();
        
        for (let i = 0; i <= numPoints; i++) {
          const x = (i / numPoints) * width;
          const t = i / numPoints;
          
          // Create organic wave shape using multiple sine waves
          const wave1 = Math.sin(t * Math.PI * 4 + time * speed + phaseOffset) * 0.5;
          const wave2 = Math.sin(t * Math.PI * 6 + time * speed * 1.3 + phaseOffset) * 0.3;
          const wave3 = Math.sin(t * Math.PI * 2 + time * speed * 0.7 + phaseOffset) * 0.2;
          
          // Combine waves with energy from mel if available
          let melInfluence = 0.5;
          if (mel && mel.length > 0) {
            const melIdx = Math.floor(t * mel.length);
            melInfluence = Math.max(0, Math.min(1, (mel[melIdx] + 10) / 10));
          }
          
          const combinedWave = (wave1 + wave2 + wave3) * (0.5 + melInfluence * 0.5);
          const beatBoost = beatPulse * 0.3;
          const y = baseY - (waveHeight * (0.5 + combinedWave * 0.5)) * (1 + beatBoost);
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            // Use quadratic curves for smoother waves
            const prevX = ((i - 1) / numPoints) * width;
            const cpX = (prevX + x) / 2;
            ctx.quadraticCurveTo(cpX, y, x, y);
          }
        }
        
        // Complete the wave shape
        ctx.lineTo(width, baseY + 5);
        ctx.lineTo(0, baseY + 5);
        ctx.closePath();
        
        // Create gradient fill
        const gradient = ctx.createLinearGradient(0, baseY - waveHeight, 0, baseY + 5);
        const alpha = 0.3 + chromaValue * 0.5 + beatPulse * 0.2;
        const lightness = 45 + chromaValue * 20;
        gradient.addColorStop(0, `hsla(${hue}, 85%, ${lightness + 15}%, ${alpha})`);
        gradient.addColorStop(0.5, `hsla(${hue}, 80%, ${lightness}%, ${alpha * 0.7})`);
        gradient.addColorStop(1, `hsla(${hue}, 75%, ${lightness - 10}%, 0.05)`);
        
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Add glow effect for prominent pitch classes
        if (chromaValue > 0.5) {
          ctx.shadowColor = `hsla(${hue}, 90%, 60%, 0.5)`;
          ctx.shadowBlur = 8 * chromaValue;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }
      
      // Draw pitch class labels at bottom
      const labelY = baseY + 18;
      ctx.font = '8px "Orbitron", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      
      for (let i = 0; i < 12; i++) {
        const x = (i + 0.5) / 12 * width;
        const chromaValue = chroma[i] || 0;
        const hue = CHROMA_HUES[i];
        const alpha = 0.3 + chromaValue * 0.7;
        ctx.fillStyle = `hsla(${hue}, 80%, 65%, ${alpha})`;
        ctx.fillText(PITCH_CLASSES[i], x, labelY);
      }
    }

    // REAL VISUALIZATION: Full visualization with actual audio data
    function drawRealVisualization(ctx, width, height, frame, time) {
      const centerX = width / 2;
      const centerY = height / 2;
      const beatStrength = frame.beatStrength || 0;
      const radius = Math.min(width, height) * 0.38;
      
      // Update visualization state
      if (frame.onBeat && beatStrength > 0.5) {
        vizState.beatPulse = 1;
        vizState.lastBeatTime = time;
      }
      vizState.beatPulse *= 0.92; // Decay
      
      // Calculate energy level from mel
      if (frame.mel && frame.mel.length > 0) {
        const avgMel = frame.mel.reduce((a, b) => a + b, 0) / frame.mel.length;
        vizState.energyLevel = Math.max(0, Math.min(1, (avgMel + 5) / 10));
      }
      
      // Calculate dominant hue from chroma
      if (frame.chroma && frame.chroma.length === 12) {
        let maxIdx = 0;
        let maxVal = 0;
        for (let i = 0; i < 12; i++) {
          if (frame.chroma[i] > maxVal) {
            maxVal = frame.chroma[i];
            maxIdx = i;
          }
        }
        vizState.dominantHue = CHROMA_HUES[maxIdx];
      }
      
      // Update chroma rotation
      vizState.chromaRotation += 0.005 + vizState.beatPulse * 0.02;
      
      // Background with fade trail
      ctx.fillStyle = 'rgba(10, 10, 15, 0.12)';
      ctx.fillRect(0, 0, width, height);
      
      // Beat flash effect
      if (vizState.beatPulse > 0.5) {
        ctx.fillStyle = `hsla(${vizState.dominantHue}, 70%, 50%, ${vizState.beatPulse * 0.1})`;
        ctx.fillRect(0, 0, width, height);
      }
      
      // Draw all visualization components
      updateAndDrawParticles(ctx, width, height, vizState.beatPulse, vizState.dominantHue, vizState.energyLevel);
      drawCircularMel(ctx, centerX, centerY, radius, frame.mel, vizState.beatPulse, vizState.dominantHue);
      drawChromaWheel(ctx, centerX, centerY, radius, frame.chroma, vizState.chromaRotation, vizState.beatPulse);
      drawPitchOrb(ctx, centerX, centerY, radius, frame.pitch || 0, frame.pitchConfidence || 0, vizState.beatPulse, vizState.dominantHue);
      drawChromaSoundWaves(ctx, width, height, frame.chroma, frame.mel, vizState.beatPulse, time);
      
      // Info overlay
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(5, 5, 160, 75);
      ctx.fillStyle = '#fff';
      ctx.font = '12px monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
      ctx.fillText(`Time: ${frame.time?.toFixed(2) || 0}s`, 10, 22);
      ctx.fillText(`BPM: ${frame.bpm?.toFixed(1) || 'N/A'}`, 10, 40);
      ctx.fillText(`Pitch: ${frame.pitch?.toFixed(0) || 0}Hz`, 10, 58);
      ctx.fillText(`Beat: ${frame.onBeat ? 'üî• YES' : 'no'}`, 10, 76);
    }

    // Start idle animation loop
    function startIdleAnimation() {
      if (visualizationState !== 'idle') return;
      
      const animate = (timestamp) => {
        if (visualizationState !== 'idle') return;
        
        const time = timestamp / 1000;
        drawIdleVisualization(ctx, canvas.width, canvas.height, time);
        idleAnimationId = requestAnimationFrame(animate);
      };
      
      idleAnimationId = requestAnimationFrame(animate);
    }

    // Start loading animation loop
    function startLoadingAnimation() {
      visualizationState = 'loading';
      if (idleAnimationId) {
        cancelAnimationFrame(idleAnimationId);
        idleAnimationId = null;
      }
      
      const animate = (timestamp) => {
        if (visualizationState !== 'loading') return;
        
        const time = timestamp / 1000;
        drawLoadingVisualization(ctx, canvas.width, canvas.height, time);
        idleAnimationId = requestAnimationFrame(animate);
      };
      
      // Clear canvas first
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      idleAnimationId = requestAnimationFrame(animate);
    }

    // Stop idle/loading animation and switch to real visualization
    function stopIdleAnimation() {
      if (idleAnimationId) {
        cancelAnimationFrame(idleAnimationId);
        idleAnimationId = null;
      }
    }
    
    // Add header row for results
    function addResultHeader() {
      document.getElementById('results-section').classList.remove('hidden');
      const div = document.createElement('div');
      div.className = 'result-wrapper';
      div.style.background = 'rgba(255,255,255,0.03)';
      div.style.borderColor = 'transparent';
      div.innerHTML = `
        <div class="result-item" style="cursor:default;font-weight:600;font-size:11px;color:rgba(255,255,255,0.4);">
          <span></span>
          <span></span>
          <span>TEST</span>
          <span>DATA</span>
          <span style="text-align:right">TIME</span>
        </div>
      `;
      resultsEl.appendChild(div);
    }

    function showAnalysisData(data) {
      document.getElementById('data-section').classList.remove('hidden');
      dataGridEl.innerHTML = `
        <div class="data-item"><span class="data-label">Duration</span><span class="data-value">${data.duration?.toFixed(2)}s</span></div>
        <div class="data-item"><span class="data-label">Sample Rate</span><span class="data-value">${data.sampleRate}Hz</span></div>
        <div class="data-item"><span class="data-label">Analysis Time</span><span class="data-value">${data.analysisTime}s</span></div>
        <div class="data-item"><span class="data-label">BPM</span><span class="data-value">${data.features?.rhythm?.bpm?.toFixed(1) || 'N/A'}</span></div>
        <div class="data-item"><span class="data-label">Mel Frames</span><span class="data-value">${data.features?.melSpectrogram?.length || 0}</span></div>
        <div class="data-item"><span class="data-label">Chroma Frames</span><span class="data-value">${data.features?.hpcpChroma?.length || 0}</span></div>
        <div class="data-item"><span class="data-label">Pitch Frames</span><span class="data-value">${data.features?.pitch?.length || 0}</span></div>
        <div class="data-item"><span class="data-label">Beats</span><span class="data-value">${data.features?.rhythm?.beats?.length || 0}</span></div>
      `;
    }

    function renderFrame(frame) {
      const width = canvas.width;
      const height = canvas.height;
      const time = frame.time || 0;
      
      // Use the full real visualization
      drawRealVisualization(ctx, width, height, frame, time);
    }

    // Run analysis tests
    async function runAnalysisTests() {
      resultsEl.innerHTML = '';
      addResultHeader();
      setStatus(`Running analysis tests on: ${currentAudioFileName}...`, 'running');
      
      // Switch to loading visualization
      startLoadingAnimation();
      
      try {
        // Test 1: Load Essentia
        let startTime = Date.now();
        await loadEssentia();
        addResult('Essentia Loading', true, 'WASM module initialized', Date.now() - startTime, {
          stats: { 'Status': 'Ready', 'Version': '0.1.3' },
          samples: [{ module: 'essentia-wasm', status: 'loaded' }]
        });
        
        // Test 2: Fetch and decode audio
        setStatus(`Fetching and decoding: ${currentAudioFileName}...`, 'running');
        startTime = Date.now();
        const audioBuffer = await fetchAudioBuffer(currentAudioUrl);
        const decodeTime = Date.now() - startTime;
        const monoSignal = audioBufferToMono(audioBuffer);
        addResult('Audio Decode', true, `${currentAudioFileName}: ${audioBuffer.duration.toFixed(1)}s @ ${audioBuffer.sampleRate}Hz, ${audioBuffer.numberOfChannels}ch`, decodeTime, {
          stats: {
            'File': currentAudioFileName,
            'Duration': `${audioBuffer.duration.toFixed(2)}s`,
            'Sample Rate': `${audioBuffer.sampleRate}Hz`,
            'Channels': audioBuffer.numberOfChannels,
            'Samples': audioBuffer.length.toLocaleString()
          },
          samples: [{ duration: audioBuffer.duration, sampleRate: audioBuffer.sampleRate, channels: audioBuffer.numberOfChannels, length: audioBuffer.length }]
        });
        
        // Test 3: Rhythm extraction
        setStatus('Extracting rhythm...', 'running');
        startTime = Date.now();
        let rhythm = { bpm: 0, beats: [], confidence: 0 };
        try {
          rhythm = await extractRhythm(monoSignal, audioBuffer.sampleRate);
          
          // Filter out any beats beyond the audio duration (sanity check)
          const validBeats = rhythm.beats.filter(t => t <= audioBuffer.duration);
          
          // Create 0.1s interval beat density data
          const frameInterval = 0.1;
          const numFrames = Math.ceil(audioBuffer.duration / frameInterval);
          const beatDensity = [];
          
          for (let i = 0; i < numFrames; i++) {
            const frameStart = i * frameInterval;
            const frameEnd = frameStart + frameInterval;
            // Count beats in this frame
            const beatsInFrame = validBeats.filter(t => t >= frameStart && t < frameEnd).length;
            beatDensity.push({
              frame: i,
              time: frameStart,
              beats: beatsInFrame
            });
          }
          
          addResult('Rhythm', true, `BPM: ${rhythm.bpm.toFixed(1)}, ${validBeats.length} beats, conf: ${rhythm.confidence.toFixed(2)}`, Date.now() - startTime, 
            {
              stats: {
                'BPM': rhythm.bpm.toFixed(1),
                'Confidence': rhythm.confidence.toFixed(3),
                'Total Beats': validBeats.length,
                'Frames (0.1s)': beatDensity.length,
                'Duration': audioBuffer.duration.toFixed(1) + 's',
                'Avg Interval': validBeats.length > 1 ? ((validBeats[validBeats.length-1] - validBeats[0]) / (validBeats.length - 1)).toFixed(3) + 's' : 'N/A'
              },
              samples: beatDensity.slice(0, 100).map(f => ({ 
                frame: f.frame, 
                time: f.time.toFixed(1) + 's', 
                beatsInFrame: f.beats 
              }))
            },
            {
              title: 'Beat Density Over Time (0.1s intervals)',
              xTitle: 'Time (s)',
              yTitle: 'Beats per 0.1s',
              traces: [{
                x: beatDensity.map(f => f.time),
                y: beatDensity.map(f => f.beats),
                type: 'scatter',
                mode: 'lines',
                fill: 'tozeroy',
                line: { color: '#1DB954', width: 1 },
                fillcolor: 'rgba(29, 185, 84, 0.3)',
                name: 'Beat Density'
              }]
            }
          );
        } catch (e) {
          addResult('Rhythm', false, e.message, Date.now() - startTime);
        }
        
        // Test 4: Pitch extraction
        setStatus('Extracting pitch...', 'running');
        startTime = Date.now();
        let pitch = [];
        try {
          pitch = await extractPitch(monoSignal, audioBuffer.sampleRate);
          
          // Calculate stats
          const confidentPitches = pitch.filter(p => p.confidence > 0.5);
          const avgPitch = confidentPitches.length > 0 
            ? confidentPitches.reduce((sum, p) => sum + p.pitch, 0) / confidentPitches.length 
            : 0;
          const maxPitch = confidentPitches.length > 0 ? Math.max(...confidentPitches.map(p => p.pitch)) : 0;
          const minPitch = confidentPitches.length > 0 ? Math.min(...confidentPitches.filter(p => p.pitch > 0).map(p => p.pitch)) : 0;
          const avgConfidence = pitch.reduce((sum, p) => sum + p.confidence, 0) / pitch.length;
          
          addResult('Pitch', pitch.length > 0, `${pitch.length} frames, avg: ${avgPitch.toFixed(1)}Hz`, Date.now() - startTime,
            {
              stats: {
                'Total Frames': pitch.length,
                'Confident Frames': confidentPitches.length,
                'Avg Pitch': avgPitch.toFixed(1) + 'Hz',
                'Min Pitch': minPitch.toFixed(1) + 'Hz',
                'Max Pitch': maxPitch.toFixed(1) + 'Hz',
                'Avg Confidence': avgConfidence.toFixed(3)
              },
              samples: pitch.slice(0, 100).map((p, i) => ({ 
                frame: i, 
                time: p.time?.toFixed(3) + 's', 
                pitch: p.pitch.toFixed(2) + 'Hz', 
                confidence: p.confidence.toFixed(3) 
              }))
            },
            {
              title: 'Pitch Over Time (All Frames)',
              xTitle: 'Time (s)',
              yTitle: 'Frequency (Hz)',
              traces: [{
                x: pitch.filter(p => p.confidence > 0.3).map(p => p.time),
                y: pitch.filter(p => p.confidence > 0.3).map(p => p.pitch),
                type: 'scattergl',
                mode: 'markers',
                marker: { 
                  color: pitch.filter(p => p.confidence > 0.3).map(p => p.confidence),
                  colorscale: [[0, '#333'], [1, '#1DB954']],
                  size: 3
                },
                name: 'Pitch'
              }]
            }
          );
        } catch (e) {
          addResult('Pitch', false, e.message, Date.now() - startTime);
        }
        
        // Test 5: Mel Spectrogram extraction
        setStatus('Extracting mel spectrogram...', 'running');
        startTime = Date.now();
        let melSpectrogram = [];
        try {
          melSpectrogram = await extractMelSpectrogram(monoSignal, audioBuffer.sampleRate);
          const avgEnergy = melSpectrogram.reduce((sum, f) => sum + f.bands.reduce((s, b) => s + b, 0) / f.bands.length, 0) / (melSpectrogram.length || 1);
          const maxEnergy = Math.max(...melSpectrogram.flatMap(f => f.bands));
          const minEnergy = Math.min(...melSpectrogram.flatMap(f => f.bands));
          
          // Create heatmap data (full dataset)
          const zData = melSpectrogram.map(f => f.bands);
          const xData = melSpectrogram.map(f => f.time);
          
          addResult('Mel Spectrogram', melSpectrogram.length > 0, `${melSpectrogram.length} frames, ${melSpectrogram[0]?.bands?.length || 0} bands, avg: ${avgEnergy.toFixed(2)}`, Date.now() - startTime,
            {
              stats: {
                'Frames': melSpectrogram.length,
                'Bands': melSpectrogram[0]?.bands?.length || 0,
                'Avg Energy': avgEnergy.toFixed(2),
                'Max Energy': maxEnergy.toFixed(2),
                'Min Energy': minEnergy.toFixed(2),
                'Duration': `${melSpectrogram[melSpectrogram.length-1]?.time?.toFixed(1) || 0}s`
              },
              samples: melSpectrogram.slice(0, 20).map((f, i) => ({
                frame: i,
                time: f.time?.toFixed(3) + 's',
                bands: f.bands.map(b => b.toFixed(2)).join(', ')
              }))
            },
            {
              title: 'Mel Spectrogram (All Frames)',
              xTitle: 'Time (s)',
              yTitle: 'Mel Band',
              traces: [{
                z: zData.length > 0 ? zData[0].map((_, bandIdx) => zData.map(frame => frame[bandIdx])) : [],
                x: xData,
                type: 'heatmap',
                colorscale: [[0, '#0a0a0f'], [0.5, '#1a4d2e'], [1, '#1DB954']],
                showscale: true
              }]
            }
          );
        } catch (e) {
          addResult('Mel Spectrogram', false, e.message, Date.now() - startTime);
        }
        
        // Test 6: Chroma extraction
        setStatus('Extracting chroma...', 'running');
        startTime = Date.now();
        let hpcpChroma = [];
        try {
          hpcpChroma = await extractHPCPChroma(monoSignal, audioBuffer.sampleRate);
          
          // Find dominant pitch class
          const chromaSums = new Array(12).fill(0);
          hpcpChroma.forEach(f => f.chroma.forEach((c, i) => chromaSums[i] += c));
          const pitchClasses = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
          const dominantIdx = chromaSums.indexOf(Math.max(...chromaSums));
          const totalEnergy = chromaSums.reduce((a, b) => a + b, 0);
          
          addResult('Chroma', hpcpChroma.length > 0, `${hpcpChroma.length} frames, dominant: ${pitchClasses[dominantIdx]}`, Date.now() - startTime,
            {
              stats: {
                'Frames': hpcpChroma.length,
                'Dominant Key': pitchClasses[dominantIdx],
                ...Object.fromEntries(pitchClasses.map((pc, i) => [pc, ((chromaSums[i] / totalEnergy) * 100).toFixed(1) + '%']))
              },
              samples: hpcpChroma.slice(0, 20).map((f, i) => ({
                frame: i,
                time: f.time?.toFixed(3) + 's',
                chroma: pitchClasses.map((pc, j) => `${pc}:${f.chroma[j].toFixed(2)}`).join(' ')
              }))
            },
            [
              // Chart 1: Chroma Distribution Bar Chart
              {
                title: 'Chroma Distribution',
                xTitle: 'Pitch Class',
                yTitle: 'Total Energy',
                traces: [{
                  x: pitchClasses,
                  y: chromaSums,
                  type: 'bar',
                  marker: { 
                    color: ['#ff6b6b', '#ff8e72', '#ffa94d', '#ffd43b', '#a9e34b', '#69db7c',
                            '#38d9a9', '#3bc9db', '#4dabf7', '#748ffc', '#9775fa', '#da77f2']
                  }
                }]
              },
              // Chart 2: Pitch Over Time (from pitch extraction data)
              {
                title: 'Pitch Over Time (All Frames)',
                xTitle: 'Time (s)',
                yTitle: 'Frequency (Hz)',
                traces: [{
                  x: pitch.filter(p => p.confidence > 0.3).map(p => p.time),
                  y: pitch.filter(p => p.confidence > 0.3).map(p => p.pitch),
                  type: 'scattergl',
                  mode: 'markers',
                  marker: { 
                    color: pitch.filter(p => p.confidence > 0.3).map(p => p.confidence),
                    colorscale: [[0, '#333'], [1, '#1DB954']],
                    size: 3
                  },
                  name: 'Pitch'
                }]
              }
            ]
          );
        } catch (e) {
          addResult('Chroma', false, e.message, Date.now() - startTime);
        }
        
        // Store analysis data
        analysisData = {
          duration: audioBuffer.duration,
          sampleRate: audioBuffer.sampleRate,
          analysisTime: 0,
          features: { melSpectrogram, hpcpChroma, pitch, rhythm }
        };
        
        showAnalysisData(analysisData);
        setStatus('Analysis tests complete!');
        
        // Switch to idle after analysis
        stopIdleAnimation();
        visualizationState = 'idle';
        startIdleAnimation();
        
      } catch (error) {
        addResult('Test Failed', false, error.message, 0);
        setStatus('Error: ' + error.message, 'error');
      }
    }

    // Run visualization tests
    async function runVisualizationTests() {
      setStatus(`Running visualization tests on: ${currentAudioFileName}...`, 'running');
      
      // Switch to real visualization state
      stopIdleAnimation();
      visualizationState = 'real';
      
      // Initialize particles
      initParticles(canvas.width, canvas.height);
      
      try {
        const startTime = Date.now();
        
        if (!analysisData) {
          startLoadingAnimation();
          await loadEssentia();
          analysisData = await analyzeAudio(currentAudioUrl);
          stopIdleAnimation();
          visualizationState = 'real';
        }
        
        // Clear canvas
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Render frames at different times
        const times = [0, 1, 2, 5, analysisData.duration / 2];
        
        for (const time of times) {
          setStatus(`Rendering frame at ${time.toFixed(1)}s...`, 'running');
          const frame = getAnalysisAtTime(analysisData, time);
          
          ctx.fillStyle = '#0a0a0f';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          drawRealVisualization(ctx, canvas.width, canvas.height, frame);
          
          await new Promise(r => setTimeout(r, 500));
        }
        
        addResult('Visualization', true, `Rendered ${times.length} test frames`, Date.now() - startTime);
        showAnalysisData(analysisData);
        setStatus('Visualization tests complete!');
        
        // Back to idle
        visualizationState = 'idle';
        startIdleAnimation();
        
      } catch (error) {
        addResult('Visualization', false, error.message, 0);
        setStatus('Error: ' + error.message, 'error');
      }
    }

    // Animate visualization
    let currentTime = 0;
    let lastTimestamp = null;

    function animate(timestamp) {
      if (!analysisData || visualizationState !== 'real') return;
      
      if (lastTimestamp === null) lastTimestamp = timestamp;
      const deltaTime = (timestamp - lastTimestamp) / 1000;
      lastTimestamp = timestamp;
      currentTime += deltaTime;
      
      if (currentTime >= analysisData.duration) {
        currentTime = 0;
      }
      
      const frame = getAnalysisAtTime(analysisData, currentTime);
      if (frame) drawRealVisualization(ctx, canvas.width, canvas.height, frame, currentTime);
      
      animationId = requestAnimationFrame(animate);
    }

    async function startAnimation() {
      // Switch to real visualization state
      stopIdleAnimation();
      visualizationState = 'real';
      
      // Initialize particles for the visualization
      initParticles(canvas.width, canvas.height);
      
      if (!analysisData) {
        startLoadingAnimation();
        setStatus(`Loading: ${currentAudioFileName}...`, 'running');
        await loadEssentia();
        analysisData = await analyzeAudio(currentAudioUrl);
        showAnalysisData(analysisData);
        stopIdleAnimation();
        visualizationState = 'real';
      }
      
      document.getElementById('btn-animate').classList.add('hidden');
      document.getElementById('btn-stop').classList.remove('hidden');
      
      currentTime = 0;
      lastTimestamp = null;
      setStatus('Playing visualization...');
      animationId = requestAnimationFrame(animate);
    }

    function stopAnimation() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      document.getElementById('btn-animate').classList.remove('hidden');
      document.getElementById('btn-stop').classList.add('hidden');
      setStatus('Animation stopped');
      
      // Back to idle
      visualizationState = 'idle';
      startIdleAnimation();
    }

    // Custom MP3
    async function loadCustomMP3() {
      document.getElementById('file-input').click();
    }

    document.getElementById('file-input').addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      
      // Validate file is an MP3
      if (!file.name.toLowerCase().endsWith('.mp3')) {
        setStatus('Error: Please select an MP3 file', 'error');
        log('‚ùå Invalid file type. File must end with .mp3', 'error');
        return;
      }
      
      // Store the custom file info
      currentAudioFileName = file.name;
      const url = URL.createObjectURL(file);
      currentAudioUrl = url;
      
      setStatus(`Loaded: ${file.name} - Ready for analysis`, 'info');
      log(`üìÅ Loaded custom MP3: ${file.name}`, 'info');
      
      // Clear previous analysis data so new file will be used
      analysisData = null;
    });

    // Event listeners
    document.getElementById('btn-analysis').addEventListener('click', runAnalysisTests);
    document.getElementById('btn-custom').addEventListener('click', loadCustomMP3);
    document.getElementById('btn-animate').addEventListener('click', startAnimation);
    document.getElementById('btn-stop').addEventListener('click', stopAnimation);

    log('Test runner ready. Add your test MP3 to /public/test-fixtures/test-audio.mp3', 'info');
    
    // Start idle animation on page load
    visualizationState = 'idle';
    startIdleAnimation();
  </script>

  <!-- Version Footer -->
  <footer class="version-footer">
    <span>Made by @Yerry - v2.1.0 (Test Runner)</span>
    <a href="/" class="settings-btn" title="Back to Main App">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
      </svg>
    </a>
  </footer>
</body>
</html>
